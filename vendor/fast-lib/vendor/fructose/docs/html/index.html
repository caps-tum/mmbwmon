<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FRUCTOSE: FRUCTOSE - FRamework for Unit testing C++ for Test driven development Of SoftwarE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>FRUCTOSE - FRamework for Unit testing C++ for Test driven development Of SoftwarE </h1>  </div>
</div>
<div class="contents">
<h3 class="version">1.2.0 </h3><h2><a class="anchor" id="intro_sec"></a>
Introduction</h2>
<p>FRUCTOSE provides a framework for quickly developing test harnesses for use in C++ unit tests. These harnesses are assumed to be part of using TDD (Test Driven Development). A given harness will run all the tests by default and silently (unless there are errors) but the harness can also be used interactively, for selected tests, and with optional verbose output.</p>
<h2><a class="anchor" id="features"></a>
Features</h2>
<ul>
<li>Assertions. Unlike some other unit test frameworks, FRUCTOSE does not use the C macro facility 'assert' for its assertions. This means that the harness can run all its tests through to completion instead of core dumping at the first failure.</li>
</ul>
<ul>
<li>Loop assertions. Macros are provided which help the developer track down the reason for assertion failures for data held in static tables. What is needed in these cases in addition to the file and line number of the assertion is the line number of the data that was tested in the assert.</li>
</ul>
<ul>
<li>Exception assertions. The test harness may assert that a condition should result in the throwing of an exception of a specified type. If it does not then the assertion fails. Similarly, a harness may assert that no exception is to be thrown upon the evaluation of a condition; if one is then the assertion fails.</li>
</ul>
<ul>
<li>floating point compare assertions. Floating point comparisons can be asserted for using relative or absolute tolerances.</li>
</ul>
<ul>
<li>Fine control over test selection. The tests are named in the harness and may be selected by name from the command line. By default all tests are run.</li>
</ul>
<ul>
<li>Each test can receive its own command line parameters. Each test can obtain any test-specific parameters that were passed using the command line.</li>
</ul>
<ul>
<li>Simple test harnesses. The harness just defines one class, where each public function is designed to be one test case. The harness class inherits from <a class="el" href="classfructose_1_1test__base.html">fructose::test_base</a>, which provides it with three functions:</li>
</ul>
<ol type="1">
<li>add_test to add a named test</li>
<li>run with no arguments runs all tests</li>
<li>run with argc and argv runs the tests specified on the command line.</li>
</ol>
<p>Note: for compatibility with older versions of fructose, two additional routines are provided:</p>
<ol type="1">
<li>get_suite returns a list of tests to run based on parsing the command line</li>
<li>run runs the tests returned by get_suite.</li>
</ol>
<ul>
<li>verbose command line argument option. The functions in the test harness class have access to the function verbose(), which returns true if the -v flag was given on the command line. This is a debugging aid during TDD whereby the harness can print useful intermediate values that might shed light on why a test is failing.</li>
</ul>
<h2><a class="anchor" id="why"></a>
Why another unit test framework?</h2>
<h3><a class="anchor" id="cppunit"></a>
CppUnit woes</h3>
<p>This framework was arrived after several weeks of struggling with CppUnit. At the time CppUnit was not even buildable on the main platform being used (Solaris). It has subsequently been ported but this was just one obstacle among many. CppUnit was judged to be too heavyweight for the needs of most simple unit test harnesses so a more lightweight library was developed. This one has just two classes, test_base and test_root, and a handful of macros for convenient assertion testing.</p>
<h3><a class="anchor" id="depends"></a>
Unit test framework dependencies</h3>
<p>Some other unit test frameworks rely on other components that are not very lightweight and not always very portable. FRUCTOSE also has tried to avoid dependencies on other external libraries. It is completely standalone. It is all done with inlined templates and so does not require a library to be linked in.</p>
<h3><a class="anchor" id="simplicity"></a>
Test harnesses must be simple</h3>
<p>Other frameworks tend to require alot of the test harnesses. There are sometimes many classes to write and several files. The objective with FRUCTOSE was to have a class that is comprised of just 3 files; the header, the implementation and the test harness. A FRUCTOSE test harness requires just one class to be defined. Each public function of that class is designed to be a test case.</p>
<h2><a class="anchor" id="not"></a>
What FRUCTOSE does not do</h2>
<p>FRUCTOSE does not attempt to provide output tailored for any particular reporting mechanism, it just writes any errors (along with any verbose output) to std::cout. It is this not designed to directly support web-based unit test report summaries, unlike CppUnit.</p>
<h2><a class="anchor" id="misc"></a>
Miscellaneous notes</h2>
<p>FRUCTOSE always writes its output on std::cout. It does not ever write to std::cerr unless it is invoked wrongly, e.g with a named test where the test name is unknown. The rational behind this is that the harness works no matter how many tests pass or fail. This is particularly useful when the verbose flag is enabled since verbose output is expected to also go to std::cout. This avoids problems with std::cout and std::cerr being out of sync (std::cout is buffered by std::cerr is not).</p>
<p>If one or more of the tests fail then the exit status is set to EXIT_FAILURE. This is so that any reporting tools built around the invocation of these test harnesses can easily determine whether any harnesses produced test failures. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 28 2012 18:30:11 for FRUCTOSE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
